#![no_std]
#![allow(internal_features)]
#![feature(lang_items)]
#![feature(never_type)]

pub mod alloc;
pub mod process;
pub mod syscall;

#[global_allocator]
static mut ALLOCATOR: alloc::Allocator = alloc::Allocator::empty();

/// Initialize the runtime. For now, this function does nothing but in the future it should
/// initialize the thread-local storage, the command line arguments, the environment variables
/// and other runtime components.
///
/// This function is NOT guaranteed to be called, for example if application code is externally
/// called.
unsafe fn init() {}

/// The lang start function.
///
/// This is a special function that will be used by the compiler to generate a C `main` function
/// that can be called by the entry point of the application. This function simply will call the
/// `init` function to setup the runtime and then call the Rust `main` function. The return value
/// of the Rust `main` function will be converted to an `i32` and returned to the C `main` function
/// that will exit the application with this value.
#[lang = "start"]
fn lang_start<T: crate::process::Termination + 'static>(
    main: fn() -> T,
    _argc: isize,
    _argv: *const *const u8,
    _sigpipe: u8,
) -> isize {
    unsafe {
        init();
    }
    main().report().to_i32() as isize
}

/// The real entry point of the application. This function is directly called by the kernel when
/// the application is started. It simply call the C function `main` and then exit with the
/// return value of `main`. The C `main` function is automatically generated by the compiler
/// using the `lang_start` function that will run some initialization code before calling the
/// Rust `main` function.
#[no_mangle]
unsafe extern "C" fn _start() -> ! {
    extern "C" {
        fn main() -> i32;
    }
    syscall::task::exit(main());
}

/// The panic handler.
///
/// This function is called when the application panics. The library does not support unwinding,
/// so this function simply print a message and exit the application. In the future, this function
/// should be able to print more information about the panic message and the backtrace.
#[panic_handler]
pub fn panic(_: &core::panic::PanicInfo) -> ! {
    syscall::serial::print("Application panicked");
    syscall::task::exit(1);
}
