#![no_std]
#![allow(internal_features)]
#![feature(lang_items)]
#![feature(never_type)]
#![feature(panic_info_message)]
#![feature(allow_internal_unstable)]

extern crate alloc;

pub mod allocator;
pub mod process;
pub mod syscall;

#[global_allocator]
static mut ALLOCATOR: allocator::Allocator = allocator::Allocator::empty();

/// Initialize the runtime. For now, this function does nothing but in the future it should
/// initialize the thread-local storage, the command line arguments, the environment variables
/// and other runtime components.
///
/// This function is NOT guaranteed to be called, for example if application code is externally
/// called.
unsafe fn init() {}

/// The lang start function.
///
/// This is a special function that will be used by the compiler to generate a C `main` function
/// that can be called by the entry point of the application. This function simply will call the
/// `init` function to setup the runtime and then call the Rust `main` function. The return value
/// of the Rust `main` function will be converted to an `i32` and returned to the C `main` function
/// that will exit the application with this value.
#[lang = "start"]
fn lang_start<T: crate::process::Termination + 'static>(
    main: fn() -> T,
    _argc: isize,
    _argv: *const *const u8,
    _sigpipe: u8,
) -> isize {
    unsafe {
        init();
    }
    main().report().to_i32() as isize
}

/// The real entry point of the application. This function is directly called by the kernel when
/// the application is started. It simply call the C function `main` and then exit with the
/// return value of `main`. The C `main` function is automatically generated by the compiler
/// using the `lang_start` function that will run some initialization code before calling the
/// Rust `main` function.
#[no_mangle]
unsafe extern "C" fn _start() -> ! {
    extern "C" {
        fn main() -> i32;
    }
    syscall::task::exit(main());
}

/// The panic handler.
///
/// This function is called when the application panics. The library does not support unwinding,
/// so this function simply print a message and exit the application.
#[panic_handler]
pub fn panic(info: &core::panic::PanicInfo) -> ! {
    if let Some(location) = info.location() {
        if let Some(message) = info.message() {
            syscall::serial::print(&alloc::format!(
                "Panic: {} at {}:{}:{}\n",
                message,
                location.file(),
                location.line(),
                location.column()
            ));
        } else {
            syscall::serial::print(&alloc::format!(
                "Panic at {}:{}:{}\n",
                location.file(),
                location.line(),
                location.column()
            ));
        }
    } else if let Some(message) = info.message() {
        syscall::serial::print(&alloc::format!("Panic: {}\n", message));
    } else {
        syscall::serial::print("Panic\n");
    }

    syscall::task::exit(1);
}
